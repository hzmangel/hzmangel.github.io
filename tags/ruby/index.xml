<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ruby on 湖间小筑</title>
    <link>http://hzmangel.github.io/tags/ruby/</link>
    <description>Recent content in Ruby on 湖间小筑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright - ©2015 - hzmangel</copyright>
    <lastBuildDate>Thu, 24 May 2012 09:25:42 +0000</lastBuildDate>
    <atom:link href="http://hzmangel.github.io/tags/ruby/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tunning Rails with DTrace</title>
      <link>http://hzmangel.github.io/post/1147/</link>
      <pubDate>Thu, 24 May 2012 09:25:42 +0000</pubDate>
      
      <guid>http://hzmangel.github.io/post/1147/</guid>
      <description>

&lt;p&gt;This post will talk about how to do performance test of Rails program with
DTrace tool. The testing will be separated into Ruby program part and database
operations part. Please make sure all the tested program has provided probes
to the DTrace.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTICE&lt;/strong&gt;: The testing data is still under collection, this post has only DTrace script now, I will update this post after gathering enough testing data.## DTrace&lt;/p&gt;

&lt;p&gt;DTrace is a dynamic tracing tool, which is safe to use in production systems
and it does not require restarting either the system or application. DTrace
consists of 4 parts: front-end, libdtrace library, in-kernel DTrace framework
and DTrace provider.&lt;/p&gt;

&lt;p&gt;DTrace is built on a foundation of objects called probes. Probes are event
handlers that will be triggered when their particular event occurs, and DTrace
can bind some actions to the probe to get needed information.&lt;/p&gt;

&lt;h3 id=&#34;basic-syntax&#34;&gt;Basic syntax&lt;/h3&gt;

&lt;p&gt;A typically D language script contains three sections, the &lt;code&gt;BEGIN&lt;/code&gt; section,
&lt;code&gt;END&lt;/code&gt; section and probe section. Sections are surrounded by braces. Each probe
description is made of four fields, separated by colon character:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;provider:module:function:name
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;privider&lt;/code&gt;: Instrumented layer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module&lt;/code&gt;: Instrumented module&lt;/li&gt;
&lt;li&gt;&lt;code&gt;function&lt;/code&gt;: Instrumented function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;: location in the function, typically is enter, return, tick-nsec&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The provider field is needed, which others are optional. Pattern matching
characters such as *, ?, […] and \ can be used. For example, this script will
get all call of &lt;code&gt;write*&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;syscall::write*:entry
{
    printf(&amp;quot;(%d): %s write call called&amp;quot;, pid, execname);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is a sample script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/sbin/dtrace -s

#pragma D option quiet

pid$target::fopen*:entry
{
    printf(&amp;quot;(%d):%s open\n&amp;quot;, pid, execname);
}

pid$target::fwrite*:entry
{
    printf(&amp;quot;(%d):%s write\n&amp;quot;, pid, execname);
}

pid$target::fread*:entry
{
    printf(&amp;quot;(%d):%s read\n&amp;quot;, pid, execname);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is a testing C program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main(int argc, char* argv[]) {
    char buffer[64];
    int size = 0;

    FILE *fp = fopen(&amp;quot;bar.c&amp;quot;, &amp;quot;r&amp;quot;);
    fread(buffer, sizeof(buffer), sizeof(char), fp);
    fclose(fp);

    FILE *fp2 = fopen(&amp;quot;/tmp/foobar&amp;quot;, &amp;quot;w&amp;quot;);
    fwrite(buffer, sizeof(buffer), sizeof(char), fp2);
    fclose(fp2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the result of running the program with given script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ./foo.d -c `pwd`/bar
(3001):bar open
(3001):bar read
(3001):bar open
(3001):bar write
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It also can support some predication before the action, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/ pid == 12345 /
/ execname == &amp;quot;bash&amp;quot; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more information, please refer to reference section:&lt;/p&gt;

&lt;h2 id=&#34;rails&#34;&gt;Rails&lt;/h2&gt;

&lt;h3 id=&#34;probes-for-ruby-and-rails-application&#34;&gt;Probes for Ruby and Rails application&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;NOTICE&lt;/strong&gt;: Make sure the Ruby you are using provides the DTrace probes, or the testing below can &lt;strong&gt;NOT&lt;/strong&gt; be continued.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTICE&lt;/strong&gt;: The Ruby 1.9.3 currently do not support DTrace, please follow this discussion for more information &lt;a href=&#34;http://bugs.ruby-lang.org/issues/2565&#34;&gt;http://bugs.ruby-lang.org/issues/2565&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I have applied the patch mentioned above to Ruby 1.9.3 and regenerate the
&lt;code&gt;configure&lt;/code&gt; file with &lt;code&gt;autoconf&lt;/code&gt; command, then compile the binary and install
it to replace the Ruby installed by &lt;em&gt;homebrew&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Probes provided by Ruby is list below:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function-entry&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;function-return&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gc-begin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gc-end&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;line&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object-create-start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object-create-end&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object-free&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;raise&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rescue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ruby-probe&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The list can be get by this command: &lt;code&gt;sudo dtrace -lP &#39;ruby*&#39;&lt;/code&gt;. The &lt;code&gt;-P&lt;/code&gt;
argument is used to specify the provider.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTICE&lt;/strong&gt;: The probe name may different than above list in different system, please refer to the output of command while writing the script.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;function*&lt;/code&gt;, &lt;code&gt;object*&lt;/code&gt; and &lt;code&gt;gc*&lt;/code&gt; probes can be used to analyse performance
while the &lt;code&gt;raise&lt;/code&gt; and &lt;code&gt;rescue&lt;/code&gt; can be used to analyse error. Since the probes
for Ruby my have some errors while running on my system, so I only choose
&lt;code&gt;function&lt;/code&gt; related probes in the script, and a summary will be printed out
after test completed.&lt;/p&gt;

&lt;p&gt;Here is the script used for testing, thanks to &lt;a href=&#34;http://andyjeffries.co.uk/articles/dtrace-and-ruby-on-rails-with-
leopard-snow-leopard&#34;&gt;this
article&lt;/a&gt; and &lt;a href=&#34;http://tenderlovemaking.com/2011/12/05/profiling-rails-startup-with-
dtrace/&#34;&gt;this
article&lt;/a&gt;, the script used here is based on their version.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/sbin/dtrace -s

#pragma D option quiet

BEGIN
{
    printf(&amp;quot;==========================\n&amp;quot;);
    printf(&amp;quot;Trace started: %Y\n&amp;quot;, walltimestamp);
    printf(&amp;quot;==========================\n&amp;quot;);
    depth = 0;
}

ruby*:::function-entry
{
    k = copyinstr(arg0);
    m = copyinstr(arg1);
    @[k, m] = count();
    self-&amp;gt;depth++;
    self-&amp;gt;start[k, m, self-&amp;gt;depth] = timestamp;
    printf(&amp;quot;-&amp;gt; %s::%s (%s:%d)\n&amp;quot;, k, m, copyinstr(arg2), arg3);
}

tick-5000hz
/k != 0/
{
      @[k, m] = count();
}

ruby*:::function-return
/(this-&amp;gt;class = copyinstr(arg0)) != NULL &amp;amp;&amp;amp; \
 (this-&amp;gt;func  = copyinstr(arg1)) != NULL &amp;amp;&amp;amp; \
 self-&amp;gt;start[this-&amp;gt;class, this-&amp;gt;func, self-&amp;gt;depth]/
{
    this-&amp;gt;elapsed = timestamp - self-&amp;gt;start[this-&amp;gt;class, this-&amp;gt;func, self-&amp;gt;depth];

    this-&amp;gt;file = copyinstr(arg2);
    this-&amp;gt;line = arg3;
    @num[this-&amp;gt;file, this-&amp;gt;line] = count();
    @eavg[this-&amp;gt;file, this-&amp;gt;line] = avg(this-&amp;gt;elapsed);
    @esum[this-&amp;gt;file, this-&amp;gt;line] = sum(this-&amp;gt;elapsed);

    self-&amp;gt;start[this-&amp;gt;class, this-&amp;gt;func, self-&amp;gt;depth] = 0;
    self-&amp;gt;depth--;
}

END
{
    printf(&amp;quot;==========================\n&amp;quot;);
    printf(&amp;quot;Trace ended: %Y\n&amp;quot;, walltimestamp);
    printf(&amp;quot;==========================\n&amp;quot;);
    normalize(@eavg, 1000);
    normalize(@esum, 1000);
    setopt(&amp;quot;aggsortpos&amp;quot;, &amp;quot;2&amp;quot;);
    printf(&amp;quot;%-33s %123s\n&amp;quot;, &amp;quot;___ OVERLAP TIMES: ___&amp;quot;,
            &amp;quot;______ ELAPSED _____&amp;quot;);
    printf(&amp;quot;%-120s %5s %6s %10s %12s\n&amp;quot;, &amp;quot;FILE&amp;quot;, &amp;quot;LINE&amp;quot;,
            &amp;quot;COUNT&amp;quot;, &amp;quot;AVG(us)&amp;quot;, &amp;quot;SUM(us)&amp;quot;);
    printa(&amp;quot;%-120.120s %5d %@6d %@10d %@12d\n&amp;quot;, @num, @eavg, @esum);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Probes primely used in the script is &lt;code&gt;function-entry&lt;/code&gt; and &lt;code&gt;function-return&lt;/code&gt;,
and the action inside the probe is to calculate the elapsed time. And some
summary information will be printed after trace end.&lt;/p&gt;

&lt;h3 id=&#34;probes-for-database-operations&#34;&gt;Probes for database operations&lt;/h3&gt;

&lt;p&gt;The performance test is also needed on Database server, MySQL has provide one
method to use DTrace to the database, please refer &lt;a href=&#34;http://dev.mysql.com/tech-
resources/articles/getting_started_dtrace_saha.html&#34;&gt;this
page&lt;/a&gt; for reference. Here is
the script used for tracing MySQL database.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/sbin/dtrace -s

#pragma D option quiet

BEGIN
{
    printf(&amp;quot;==========================\n&amp;quot;);
    printf(&amp;quot;Trace started: %Y\n&amp;quot;, walltimestamp);
    printf(&amp;quot;==========================\n&amp;quot;);
    depth = 0;
}

pid$target::*mysql_parse*:entry
{
    self-&amp;gt;query = copyinstr(arg1);
}

mysql*:::query-start
{
    self-&amp;gt;query = copyinstr(arg0);
    self-&amp;gt;connid = arg1;
    self-&amp;gt;db = copyinstr(arg2);
    self-&amp;gt;who = strjoin(copyinstr(arg3),strjoin(&amp;quot;@&amp;quot;,copyinstr(arg4)));
    self-&amp;gt;start = timestamp;
}

mysql*:::query-done
/ self-&amp;gt;start /
{
    this-&amp;gt;elapsed = timestamp - self-&amp;gt;start;
    @time[self-&amp;gt;query] = quantize(this-&amp;gt;elapsed);
    printf(&amp;quot;%-20s %-20s %-40s %-9d\n&amp;quot;, self-&amp;gt;who, self-&amp;gt;db, self-&amp;gt;query, this-&amp;gt;elapsed / 1000000);
    self-&amp;gt;query = 0;
    self-&amp;gt;start = 0;
}


END
{
    printf(&amp;quot;==========================\n&amp;quot;);
    printf(&amp;quot;Trace ended: %Y\n&amp;quot;, walltimestamp);
    printf(&amp;quot;==========================\n&amp;quot;);

    printf(&amp;quot;MySQL query execution latency (ns):\n&amp;quot;);
    printa(@time);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script will print out time consumed by query command. There are some more
detailed probe, which can be used to monitor the time consumbed by each type
of command, please check the document if more information is needed.&lt;/p&gt;

&lt;h3 id=&#34;result-analysis&#34;&gt;Result analysis&lt;/h3&gt;

&lt;p&gt;The output is different from the two script listed above. In the log message
of Ruby, the filename and line number information are saved, which can be used
to locate the bottle neck. While the MySQL probe is easy to use, after
separating the command type, the performance can be optimized.&lt;/p&gt;

&lt;p&gt;The testing data is still under development, and I will update the blog after
get the result.&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tenderlovemaking.com/2011/12/05/profiling-rails-startup-with-dtrace/&#34;&gt;http://tenderlovemaking.com/2011/12/05/profiling-rails-startup-with-dtrace/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.oreilly.com/rails2008/public/schedule/detail/1945&#34;&gt;http://en.oreilly.com/rails2008/public/schedule/detail/1945&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/cd/E19253-01/819-5488/gcfgt/index.html&#34;&gt;http://docs.oracle.com/cd/E19253-01/819-5488/gcfgt/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tablespace.net/quicksheet/dtrace-quickstart.html&#34;&gt;http://www.tablespace.net/quicksheet/dtrace-quickstart.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.princeton.edu/~unix/Solaris/troubleshoot/dtrace.html&#34;&gt;http://www.princeton.edu/~unix/Solaris/troubleshoot/dtrace.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dev.mysql.com/tech-resources/articles/getting_started_dtrace_saha.html&#34;&gt;http://dev.mysql.com/tech-resources/articles/getting_started_dtrace_saha.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.youtube.com/watch?v=mRf4bpEtI6I&#34;&gt;http://www.youtube.com/watch?v=mRf4bpEtI6I&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://andyjeffries.co.uk/articles/dtrace-and-ruby-on-rails-with-leopard-snow-leopard&#34;&gt;http://andyjeffries.co.uk/articles/dtrace-and-ruby-on-rails-with-leopard-snow-leopard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dev.mysql.com/tech-resources/articles/getting_started_dtrace_saha.html&#34;&gt;http://dev.mysql.com/tech-resources/articles/getting_started_dtrace_saha.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>RoR learning log (2)</title>
      <link>http://hzmangel.github.io/post/1125/</link>
      <pubDate>Mon, 07 May 2012 23:57:16 +0000</pubDate>
      
      <guid>http://hzmangel.github.io/post/1125/</guid>
      <description>&lt;p&gt;This article will finish the ToDo web application, and the prime area in this
article is adding validator and updating templates.&lt;/p&gt;

&lt;p&gt;Here is &lt;a href=&#34;http://www.hzmangel.info/blog/archives/1113&#34;&gt;to RoR learning log (1)&lt;/a&gt;According to the requirements, the length of ToDo account should less than 100
characters and the status of ToDo can only be chosen from 0 or 1, so some
validator should be added to the model. With the validator, the model code
should be looked like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;STATUS_OPTION = [0, 1]

class ToDo &amp;lt; ActiveRecord::Base
  attr_accessible :content, :status
  validates :content, :presence =&amp;gt; true,
                      :length =&amp;gt; { maximum: 100 }
  validates :status, :presence =&amp;gt; true,
                     :numericality =&amp;gt; { :only_integer =&amp;gt; true },
                     :inclusion =&amp;gt; { :in =&amp;gt; STATUS_OPTION }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Statements started with &lt;code&gt;validates&lt;/code&gt; keyword are validator. The available
condition list can be checked at &lt;a href=&#34;http://guides.rubyonrails.org/active_record_validations_callbacks.html&#34;&gt;this
page&lt;/a&gt;.
If the value passed in break the rule, the error message will be shown in the
page.&lt;/p&gt;

&lt;p&gt;With the validators, the value saved can be guaranteed to be correct. But
seems radio box or drop down box is better than the text field, so we plan to
modify the template page. The template is placed under &lt;code&gt;app/views/to_dos&lt;/code&gt;
directory, which is a HTML file with some template control commands. By
default, when viewing the URL http://[address]/index, the template with the
same name, index.html.erb, will be rendered. The generated form is saved in
file &lt;code&gt;_form.html.erb&lt;/code&gt;, the default type of status is &lt;code&gt;number_field&lt;/code&gt;, which
should be updated to &lt;code&gt;select&lt;/code&gt;. The document for &lt;code&gt;select&lt;/code&gt; is &lt;a href=&#34;http://api.
rubyonrails.org/classes/ActionView/Helpers/FormOptionsHelper.html#M001593&#34;&gt;here&lt;/a&gt;,
according the document, the option list should be provided, and here we can
use the constant &lt;code&gt;STATUS_OPTION&lt;/code&gt; defined in model file. Here is the updated
&lt;code&gt;status&lt;/code&gt; field in the form object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%= f.label :status %&amp;gt;  

  &amp;lt;%= f.select :status, ToDo::STATUS_OPTION %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The form type will change from text field to drop down menu after updating the
form.&lt;/p&gt;

&lt;p&gt;Congratulations, a simple ToDo application has been worked out. It is a very
simple application, which do not contain the static files, user
authentication, unit test and so on. In next step, I plan to re-write the
&lt;a href=&#34;http://www.linuxfb.org&#34;&gt;linuxfb&lt;/a&gt; website with more better structure, hope can
touch more features in RoR.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RoR learning log (1)</title>
      <link>http://hzmangel.github.io/post/1113/</link>
      <pubDate>Mon, 07 May 2012 00:51:32 +0000</pubDate>
      
      <guid>http://hzmangel.github.io/post/1113/</guid>
      <description>

&lt;p&gt;Just back from vacation, so the study log for this week is simple.### Build development environment&lt;/p&gt;

&lt;p&gt;The whole process is tested on Mac OS, and I think this may have little
difference with Linux.&lt;/p&gt;

&lt;p&gt;Ruby should be installed before trying Rails. To separate with the Ruby used
by system, it is recommended to use RVM (Ruby version manager) to build the
local Ruby environment (seems like the virtualenv in Python). Here is the
install script from &lt;a href=&#34;https://rvm.io//rvm/install/&#34;&gt;RVM installing page&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L get.rvm.io | bash -s stable
$ source ~/.rvm/scripts/rvm
$ rvm requirements
$ rvm install 1.9.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After installing, the command &lt;code&gt;rvm use&lt;/code&gt; can be used to select the version of
Ruby.&lt;/p&gt;

&lt;p&gt;Next per-requisite is gem, which can be get from &lt;a href=&#34;http://rubyforge.org/frs/?group_id=126&#34;&gt;this
page&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Then we can use gem to install rails&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install rails
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-simple-todo-list&#34;&gt;A simple TODO list&lt;/h3&gt;

&lt;p&gt;This section will implement a todo list application, which is copied from
&lt;a href=&#34;http://bottlepy.org/docs/dev/tutorial_app.html&#34;&gt;bottle tutorial page&lt;/a&gt;. Here
is the goal copied from that page:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At the end of this tutorial, we will have a simple, web-based ToDo list. The
list contains a text (with max 100 characters) and a status (0 for closed, 1
for open) for each item. Through the web-based user interface, open items can
be view and edited and new items can be added.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This log only create the default controller, and some other thing such as
adding validator and modifying template will be shown in next log.&lt;/p&gt;

&lt;p&gt;First, we have to create the directory for application. We named the
application to &lt;code&gt;todo_app&lt;/code&gt;, and we run this command to do the initialization:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rails new todo_app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After plenty of output message, we have a new directory named todo_app, and
the directory structure has been initialized in it. After running &lt;code&gt;rails
server&lt;/code&gt; in the directory, we can access the default website via
&lt;a href=&#34;http://127.0.0.1:3000&#34;&gt;http://127.0.0.1:3000&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Next step is generate database schema for this application. As mentioned
above, the schema contains two fields, one is record content, the other is
status of record. Rails provide a generator script to simplify the operation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rails generate scaffold ToDo content:string status:integer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then use rake command to migrate the database&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rake db:migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script will generate URL mapping, model and default view for the ToDo
table. You can use &lt;a href=&#34;http://127.0.0.1:3000/to_dos&#34;&gt;http://127.0.0.1:3000/to_dos&lt;/a&gt; to access the new added things
(You can check the config/routes.rb to find the correct mapping). There is no
data currently, but there is a link to add new record, which is linked to
&lt;a href=&#34;http://127.0.0.1:3000/to_dos/new&#34;&gt;http://127.0.0.1:3000/to_dos/new&lt;/a&gt;. And after record added, there will be show,
edit and destroy action to each record.&lt;/p&gt;

&lt;p&gt;The controller, view and model is saved in app directory. The file
app/controllers/to_dos_controller.rb will handle the request sent from
browser, the file app/models/to_do.rb is the model of ToDo record, and the
files under app/views/to_dos/ will show the returned record. In this demo
project, we need add some validation while adding ToDo record, and modify the
list page for updating the ToDo record.&lt;/p&gt;

&lt;p&gt;For now, there is a simple web application, can use generated
view/controller/model to manager ToDo list. In the next log, this application
will have a validator and new template.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby learning log</title>
      <link>http://hzmangel.github.io/post/1101/</link>
      <pubDate>Sat, 28 Apr 2012 11:34:51 +0000</pubDate>
      
      <guid>http://hzmangel.github.io/post/1101/</guid>
      <description>

&lt;p&gt;Just studied Ruby with the tutorial on website &lt;a href=&#34;http://rubylearning.com/&#34; target=&#34;_blank&#34;&gt;rubylearning.com&lt;/a&gt; in the past week, and here are some knowledge gained those days.#### General&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ruby is free format and case sensitive.&lt;/li&gt;
&lt;li&gt;Besides commenting one line code with leading #, Ruby can use &lt;code&gt;=being&lt;/code&gt; and &lt;code&gt;=end&lt;/code&gt; to define a comment block.&lt;/li&gt;
&lt;li&gt;Everything in Ruby is object. Which means 1.5 means a float number but 1.times can generate a enumerator.&lt;/li&gt;
&lt;li&gt;Ruby use &lt;code&gt;nil&lt;/code&gt; to indicate a NULL object&lt;/li&gt;
&lt;li&gt;Only &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; is false. Be careful, you have to face the fact that &lt;code&gt;if 0&lt;/code&gt; will do not enter else branch in Ruby, which is different with other language I have learned.&lt;/li&gt;
&lt;li&gt;There is no &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; in Ruby, you can work around with &lt;code&gt;+=1&lt;/code&gt; and &lt;code&gt;-=1&lt;/code&gt; sometimes.&lt;/li&gt;
&lt;li&gt;Constant name must start with capital letter, and local variable must start with lowercase letter or underscore(&lt;code&gt;_&lt;/code&gt;). Program can not be executed if name do not obey this rule (hmm&amp;hellip; Python use force indent, while Ruby use force name type).&lt;/li&gt;
&lt;li&gt;In Ruby, constant, class and module are all treated as constant, so must follow the constant name rule.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parentheses are optional while defining or calling function, so all the code following is legal:&lt;/p&gt;

&lt;p&gt;foobar
foobar()&lt;/p&gt;

&lt;p&gt;foobar(a, b, c)
foobar a, b, c&lt;/p&gt;

&lt;p&gt;def foo bar
    puts bar
end&lt;/p&gt;

&lt;p&gt;def foo(bar)
    puts bar
end&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;.to_i&lt;/code&gt;, &lt;code&gt;.to_f&lt;/code&gt; and &lt;code&gt;.to_s&lt;/code&gt; are used to convert object to integer, float and string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can insert underscore(_) in integer number to make it more readable.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;variable-and-method&#34;&gt;Variable and method&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Global, local, instance and class variable are defined in different way&lt;/li&gt;
&lt;li&gt;Variable with prefix &lt;code&gt;$&lt;/code&gt; means global variable&lt;/li&gt;
&lt;li&gt;Variable with prefix &lt;code&gt;@&lt;/code&gt; means instant variable in class, like &lt;code&gt;self.var&lt;/code&gt; in Python&lt;/li&gt;
&lt;li&gt;Variable with prefix &lt;code&gt;@@&lt;/code&gt; means the class variable, like static variable in C++&lt;/li&gt;
&lt;li&gt;Ruby also include some built in variable:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$0&lt;/code&gt; means the filename.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$:&lt;/code&gt; means search path, which is a list, like the &lt;code&gt;sys.path&lt;/code&gt; in Python.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$$&lt;/code&gt; means the process id.&lt;/li&gt;
&lt;li&gt;Usually, a variable can be assigned default value with this syntax: &lt;code&gt;var ||=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Only &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; can be used as suffix to the method&lt;/li&gt;
&lt;li&gt;method name ends with &lt;code&gt;?&lt;/code&gt; means this method will return boolean value.&lt;/li&gt;
&lt;li&gt;method name ends with &lt;code&gt;!&lt;/code&gt; means this method will do changes on original object instead of creating new copy.&lt;/li&gt;
&lt;li&gt;method name ends with &lt;code&gt;=&lt;/code&gt; can used to define operator.&lt;/li&gt;
&lt;li&gt;If no &lt;code&gt;return&lt;/code&gt; at last of function, the value of last expression will be returned as return value.&lt;/li&gt;
&lt;li&gt;Argument of method can be defined as &lt;code&gt;*args&lt;/code&gt;, which means the method can accept uncertain number of argument.&lt;/li&gt;
&lt;li&gt;Seems there is no &lt;code&gt;**args&lt;/code&gt; in Ruby, arguments passed with &lt;code&gt;*args&lt;/code&gt; will lost information of argument name. The &lt;code&gt;**args&lt;/code&gt; used in Python method can accept argument with name.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alias&lt;/code&gt; can be used to define a alias for a method/operator/global var/regular expression back-ref, but not local var/class var/constant. The object pointed by new name will NOT updated after updating old one.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;string&#34;&gt;String&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Ruby use &lt;code&gt;puts&lt;/code&gt; to print string to screen, and &lt;code&gt;gets&lt;/code&gt; to receive string from standard input.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;puts&lt;/code&gt; is used like a keyword, but actually it is a method defined in Ruby kernel&lt;/li&gt;
&lt;li&gt;&lt;code&gt;puts&lt;/code&gt; method will invoke &lt;code&gt;to_s&lt;/code&gt; method of an object&lt;/li&gt;
&lt;li&gt;Strings fetched with &lt;code&gt;gets&lt;/code&gt; will usually be tidied by &lt;code&gt;chomp&lt;/code&gt; method&lt;/li&gt;
&lt;li&gt;You can use &lt;code&gt;+&lt;/code&gt; to connect string. Like Python, it will create a new string object, so the performance may downgrade if connecting too may string with &lt;code&gt;+&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;String defined by single quota and double quota are different. A string defined by single quota only convert &lt;code&gt;\\\\&lt;/code&gt; to &lt;code&gt;\\&lt;/code&gt;, which means &lt;code&gt;&#39;a\\\n&#39;&lt;/code&gt; == &lt;code&gt;&#39;a\n&#39;&lt;/code&gt;, and all the three character will be printed out with &lt;code&gt;puts&lt;/code&gt;. While the double quota will convert all escape string, further more, it will also handle the expression interpolation &lt;code&gt;#{}&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;There are three methods to compare string, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;eql?&lt;/code&gt; and &lt;code&gt;equal?&lt;/code&gt;. The first two methods compare string content while the last one compares object id.&lt;/li&gt;
&lt;li&gt;A magic keyword &lt;code&gt;%w&lt;/code&gt; can be used to build string array, like this: %w{ab cd ef gh \n} == [&amp;ldquo;ab&amp;rdquo;, &amp;ldquo;cd&amp;rdquo;, &amp;ldquo;ef&amp;rdquo;, &amp;ldquo;gh&amp;rdquo;, &amp;ldquo;\\n&amp;rdquo;].&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;flow-control-and-code-block&#34;&gt;Flow control and code block&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if..else..end&lt;/code&gt;, and the else if is written as &lt;code&gt;elsif&lt;/code&gt; in Ruby. (hmm&amp;hellip; we have &lt;code&gt;else if&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;elif&lt;/code&gt; yet, and now we have &lt;code&gt;elsif&lt;/code&gt;, seems we only need elf now).&lt;/li&gt;
&lt;li&gt;There is reverse if, named &lt;code&gt;unless&lt;/code&gt;, help to write complex logic?&lt;/li&gt;
&lt;li&gt;There is &lt;code&gt;cond ? a : b&lt;/code&gt; operator in Ruby.&lt;/li&gt;
&lt;li&gt;There is a switch-case model in Ruby, &lt;code&gt;case..when..else..end&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Code blocks are defined in &lt;code&gt;{ }&lt;/code&gt; (single line) or &lt;code&gt;do..end&lt;/code&gt; (multiple line). The &lt;code&gt;{ }&lt;/code&gt; has higher precedence than &lt;code&gt;do..end&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Code block followed by function will be executed after &lt;code&gt;yield&lt;/code&gt; called in the function.&lt;/li&gt;
&lt;li&gt;Can pass argument to block by passing argument to &lt;code&gt;yield&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Method &lt;code&gt;block_given?&lt;/code&gt; can be used in function to check whether this function has block followed.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;array-range-and-hash&#34;&gt;Array, range and hash&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Seems there is no index error in Ruby, you will get &lt;code&gt;nil&lt;/code&gt; if try to access element out of array size.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARGV&lt;/code&gt; means command line arguments, which is an array.&lt;/li&gt;
&lt;li&gt;Range can be generated via &lt;code&gt;a..b&lt;/code&gt; or &lt;code&gt;a...b&lt;/code&gt;, the list generated with three dots do not contain &lt;code&gt;b&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.to_a&lt;/code&gt; method can convert a range object to array.&lt;/li&gt;
&lt;li&gt;There is a &lt;code&gt;===&lt;/code&gt; operator in range object, check whether the element is included in range.&lt;/li&gt;
&lt;li&gt;Name start with &lt;code&gt;:&lt;/code&gt; is a symbol, which is unique in global.&lt;/li&gt;
&lt;li&gt;There is a symbol table in Ruby, which contains function, class variable (variable start with &lt;code&gt;@&lt;/code&gt;) and user defined symbol. &lt;code&gt;Symbol.all_symbols&lt;/code&gt; can be used to get all symbol name, w/o colon.&lt;/li&gt;
&lt;li&gt;Symbol can not be used as a left value. It is just a symbol, can be used as right value.&lt;/li&gt;
&lt;li&gt;For string comparison and hash index, a temp string will create a new object each time, which may reduce the performance.&lt;/li&gt;
&lt;li&gt;There is a &lt;code&gt;to_s&lt;/code&gt; method for symbol, and a &lt;code&gt;to_sym&lt;/code&gt; method for string.&lt;/li&gt;
&lt;li&gt;Save information in string if take more concern on content, and symbol for object id.&lt;/li&gt;
&lt;li&gt;Hash (dict in python) can use any object as key, which is different with Python.&lt;/li&gt;
&lt;li&gt;It is recommended to use symbol to replace the string index&lt;/li&gt;
&lt;li&gt;Hash can be defined via &lt;code&gt;{key: val}&lt;/code&gt; or &lt;code&gt;{key =&amp;amp;gt; val}&lt;/code&gt;. If using the first method, the &lt;code&gt;key&lt;/code&gt; can not be a string, but a name obey the variable rule, and Ruby will convert it to symbol. That is: {a: 2} == {:a =&amp;gt; 2}&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;file&#34;&gt;File&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Usual way for using File: &lt;code&gt;File.open() do |f| .. end&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Can define file encoding and internal encoding in the open command, which is better than built-in &lt;code&gt;open&lt;/code&gt; of Python&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Find.find()&lt;/code&gt; will traverse the directory, include sub directory.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;File.new()&lt;/code&gt; can open a random access file, which can response to &lt;code&gt;.seek&lt;/code&gt; method.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;regular-expression&#34;&gt;Regular expression&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Pattern enclosed by slash is an regular expression object, &lt;code&gt;/foobar/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Both string and regular expression has match method. RE use &lt;code&gt;match&lt;/code&gt; while string use &lt;code&gt;=~&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.match&lt;/code&gt; in RE will return &lt;code&gt;MatchData&lt;/code&gt; object of matched, or &lt;code&gt;nil&lt;/code&gt; for not found.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=~&lt;/code&gt; in string will return index if found, or &lt;code&gt;nil&lt;/code&gt; for not found.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;class&#34;&gt;Class&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;class is a first-class object in Ruby, which is an object of Class.&lt;/li&gt;
&lt;li&gt;As mentioned before, the class name must has first character uppercased.&lt;/li&gt;
&lt;li&gt;Create a new object with &lt;code&gt;ClassName.new&lt;/code&gt;, which will invoke &lt;code&gt;allocate&lt;/code&gt; method to allocate space and &lt;code&gt;initalize&lt;/code&gt; method for initialization.&lt;/li&gt;
&lt;li&gt;Variable with prefix &lt;code&gt;@&lt;/code&gt; is class variable, which can be used in the whole object, seems like the &lt;code&gt;self.&lt;/code&gt; variable in Python, but in Ruby, name with &lt;code&gt;self.&lt;/code&gt; must function, then, the first character must be uppercased.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;methods&lt;/code&gt; method can be used to printed out all methods in class, like the &lt;code&gt;dir&lt;/code&gt; in Python.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;responsed_to?&lt;/code&gt; method can be used to check whether the method exists in the object. If not, Ruby first will check whether there is &lt;code&gt;method_mission&lt;/code&gt; method first, and then throw exception of not found.&lt;/li&gt;
&lt;li&gt;Every class in Ruby is open, which means you can update any class, include built-in class like string, at anytime. But make sure you will not bring the conflict into exist class.&lt;/li&gt;
&lt;li&gt;A more safer way is define a sub-class, and override the needed method.&lt;/li&gt;
&lt;li&gt;In Ruby, one class can only be inherit from a single class. However, module can be used as multi inherit, seems like the interface in Java.&lt;/li&gt;
&lt;li&gt;If calling &lt;code&gt;super&lt;/code&gt; in one class, the method in parent class will be executed, but different syntax can cause different result:&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;super&lt;/code&gt; with no parentheses, then the argument in sub method will be passed to parent method.&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;super&lt;/code&gt; with empty parentheses, then the default value of parent method will be used, and error will be reported if no default value defined.&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;super&lt;/code&gt; with value, then pass this value to parent method.&lt;/li&gt;
&lt;li&gt;Abstract class, seems more like syntax sugar. Calling undefined method in parent class, and implement the method in subclass.&lt;/li&gt;
&lt;li&gt;The default access rule for method in class is public, can add protect/private before def if needed.&lt;/li&gt;
&lt;li&gt;Those access type can be only applied to method, the instance/class variable is private by default.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;proc&#34;&gt;Proc&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Like lambda in Python, but named Proc in Ruby.&lt;/li&gt;
&lt;li&gt;Each code block created by &lt;code&gt;lambda&lt;/code&gt; is a object of &lt;code&gt;Proc&lt;/code&gt; class, which can be executed by calling &lt;code&gt;.call&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Here is a example for lambda with argument: &lt;code&gt;lambda {|x| &amp;quot;Hello #{x}&amp;quot;}&lt;/code&gt;.call &amp;ldquo;Hell&amp;rdquo;`&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;load-and-require&#34;&gt;Load and require&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;load&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; are methods defined in &lt;code&gt;Object&lt;/code&gt;, but more like a keyword during usage.&lt;/li&gt;
&lt;li&gt;File included by &lt;code&gt;load&lt;/code&gt; will be loaded every time program executed, while &lt;code&gt;require&lt;/code&gt; only once.&lt;/li&gt;
&lt;li&gt;Pass filename w/o suffix to &lt;code&gt;require&lt;/code&gt;, and &lt;code&gt;require&lt;/code&gt; will find the file in the path. If the suffix is rb, then imported as source file. For library suffix, like .so, .dll, &lt;code&gt;require&lt;/code&gt; will import them as Ruby extension.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;require&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; after execution complete.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;exception&#34;&gt;Exception&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A special class, user can throw it via &lt;code&gt;raise&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Default exception type is &lt;code&gt;RuntimeError&lt;/code&gt;, but can be changed by passing class name to &lt;code&gt;raise&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;rescue&lt;/code&gt; to handle the exception.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>