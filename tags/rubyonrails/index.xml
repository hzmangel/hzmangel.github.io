<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rubyonrails on 湖间小筑</title>
    <link>http://hzmangel.github.io/tags/rubyonrails/</link>
    <description>Recent content in Rubyonrails on 湖间小筑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright - ©2015 - hzmangel</copyright>
    <lastBuildDate>Wed, 27 Jan 2016 23:21:42 +0800</lastBuildDate>
    <atom:link href="http://hzmangel.github.io/tags/rubyonrails/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Use Different Auth Method In Rails API Controller
</title>
      <link>http://hzmangel.github.io/post/different_auth_method_in_rails_api/</link>
      <pubDate>Wed, 27 Jan 2016 23:21:42 +0800</pubDate>
      
      <guid>http://hzmangel.github.io/post/different_auth_method_in_rails_api/</guid>
      <description>&lt;p&gt;开发的时候碰到一个问题，Rails的controller是用devise来提供认证的，如果用户在访问时没有有效的cookie就会被转到登录界面。但是在API的时候不能用cookie，所以需要分开做验证。&lt;/p&gt;

&lt;p&gt;基本想法是对于网页端的请求，继续使用devise进行认证，而对于某些同时提供API接口的Action，则使用token来验证。除此之外，对于POST请求，还需要跳过CSRF token的检查。基本上代码就是这样的（为了测试方便，使用了自己定义的&lt;code&gt;before_action&lt;/code&gt; ，同时设置所有的检查都基于请求中的 &lt;em&gt;token&lt;/em&gt; 字段。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class WelcomeController &amp;lt; ApplicationController
  before_action :auth_user!, only: [:foo], unless: -&amp;gt; { request.format.json? }
  before_action :auth_by_token!, if: -&amp;gt; { request.format.json? }

  def foo
    render json: params
  end

  def bar
    render json: params
  end

  private

  def auth_user!
    head :forbidden if params[:token] != &#39;24&#39;
  end

  def auth_by_token!
    head :forbidden if params[:token] != &#39;42&#39;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时，如果使用浏览器访问 &lt;em&gt;foo&lt;/em&gt; , &lt;code&gt;request.format&lt;/code&gt; 为 &lt;em&gt;text/html&lt;/em&gt; ，此时就会调用 &lt;code&gt;auth_user!&lt;/code&gt; ，而访问 &lt;em&gt;bar&lt;/em&gt; 时，即使是使用浏览器，也不会调用 &lt;code&gt;auth_user!&lt;/code&gt; 。而对于API请求，统一都会调用 &lt;code&gt;auth_by_token!&lt;/code&gt; 进行邓处理。&lt;/p&gt;

&lt;p&gt;下面是一个简单的测试用例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &amp;quot;rails_helper&amp;quot;

RSpec.describe WelcomeController, :type =&amp;gt; :controller do
  describe &#39;GET #foo.html&#39; do
    it &#39;responds forbidden if not given valid token&#39; do
      get :foo
      expect(response).to have_http_status(:forbidden)
    end

    it &#39;responds forbidden if given wrong token&#39; do
      get :foo, {token: 42}
      expect(response).to have_http_status(:forbidden)
    end

    # auth_user! is invoked
    it &#39;responds success if given correct token&#39; do
      get :foo, {token: 24}
      expect(response).to have_http_status(:ok)
    end
  end

  describe &#39;GET #foo.json&#39; do
    before :each do
      request.env[&amp;quot;HTTP_ACCEPT&amp;quot;] = &#39;application/json&#39;
    end

    it &#39;responds forbidden if not given valid token&#39; do
      get :foo
      expect(response).to have_http_status(:forbidden)
    end

    it &#39;responds forbidden if given wrong token&#39; do
      get :foo, {token: 24}
      expect(response).to have_http_status(:forbidden)
    end

    # auth_by_token! is invoked
    it &#39;responds success if given correct token&#39; do
      get :foo, {token: 42}
      expect(response).to have_http_status(:ok)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在老版本的Rails上，有一个&lt;a href=&#34;https://github.com/rails/rails/issues/9703&#34;&gt;bug#9703&lt;/a&gt;，就是它的判断会把 if/unless 和 only/except 分开处理。在这种情况下需要根据 &lt;a href=&#34;https://github.com/rails/rails/issues/9703#issuecomment-15830313&#34;&gt;此条评论&lt;/a&gt; 中的内容对代码做相应改动。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>