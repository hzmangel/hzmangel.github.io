<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rubyonrails on 湖间小筑</title>
    <link>http://hzmangel.github.io/tags/rubyonrails/</link>
    <description>Recent content in Rubyonrails on 湖间小筑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright - ©2015 - hzmangel</copyright>
    <lastBuildDate>Wed, 10 Aug 2016 00:07:40 +0800</lastBuildDate>
    <atom:link href="http://hzmangel.github.io/tags/rubyonrails/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rails - Fix ActiveModel::ForbiddenAttributesError in grape
</title>
      <link>http://hzmangel.github.io/post/grape_n_strong_parameter/</link>
      <pubDate>Wed, 10 Aug 2016 00:07:40 +0800</pubDate>
      
      <guid>http://hzmangel.github.io/post/grape_n_strong_parameter/</guid>
      <description>&lt;p&gt;最近尝试在 &lt;em&gt;Grape API&lt;/em&gt; 中创建一个 &lt;em&gt;ActiveModel&lt;/em&gt; ，但是在使用 &lt;code&gt;new&lt;/code&gt; 创建的时候发现会报 &lt;code&gt;ActiveModel::ForbiddenAttributesError&lt;/code&gt; 错误。想了想估计是碰上了 &lt;em&gt;stronng parameters&lt;/em&gt; 的问题。按照之前的经验，那就是给参数加上一个permit，但是发现在调用 &lt;code&gt;permit!&lt;/code&gt; 之后，grape的params变成了空字典，从而造成后续的创建出错。在网上找了一圈，结果发现 grape 自己的Github页面上就有说明，如果需要和 Rails 4 一起使用，需要加上 &lt;em&gt;hashie-forbidden_attributes&lt;/em&gt; gem。&lt;/p&gt;

&lt;p&gt;细看了眼原因，因为在Rails中，默认传递的params类型为 &lt;code&gt;ActionController::Parameters&lt;/code&gt; ，而在这个类下可以直接调用 &lt;code&gt;permit&lt;/code&gt; 或 &lt;code&gt;permit!&lt;/code&gt; 的方法来完成参数设置，同时会提供 &lt;code&gt;permitted?&lt;/code&gt; 函数来检查参数是否有效。而 grape 默认传入的参数类型是 &lt;code&gt;Hashie::Mash&lt;/code&gt; ，并没有提供 &lt;code&gt;permit&lt;/code&gt; 函数。好在 Ruby 支持 &lt;em&gt;Monkey Patch&lt;/em&gt; 所以新增的这个 gem 在 &lt;code&gt;Hashie::Mash&lt;/code&gt; 类中加上了对函数 &lt;code&gt;:permitted?&lt;/code&gt; 的响应，从而解决了这个问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rails - Reload Parent Page in iframe
</title>
      <link>http://hzmangel.github.io/post/rails_reload_parent_in_iframe/</link>
      <pubDate>Sun, 17 Apr 2016 12:59:42 +0800</pubDate>
      
      <guid>http://hzmangel.github.io/post/rails_reload_parent_in_iframe/</guid>
      <description>&lt;p&gt;最近碰到的一个问题，弹出的 iframe 窗口在做完操作并把结果返回给 controller 后，调用 &lt;code&gt;render&lt;/code&gt; 或 &lt;code&gt;redirect_to&lt;/code&gt; 时都只会刷新 iframe 中的内容，而不会将整个页面都刷新。尝试在 iframe 中提交表单时关闭 iframe 窗口，但是依然无效。最后发现还是需要借助于 Javascript ，最后的解决方案如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class FooController &amp;lt; ApplicationController
  def parent_reload
    render text: &amp;quot;&amp;lt;script&amp;gt;window.parent.location.reload();&amp;lt;/script&amp;gt;&amp;quot;
  end

  def parent_redirect_to(url)
    render text: &amp;quot;&amp;lt;script&amp;gt;window.parent.location.href=&#39;#{url}&#39;;&amp;lt;/script&amp;gt;&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是直接把 Javascript 以 HTML 的形式返回给浏览器端，浏览器端在收到内容后自动执行其中的脚本。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Integrate Rails with Elasticsearch - Indexing
</title>
      <link>http://hzmangel.github.io/post/rails_elasticsearch_indexing/</link>
      <pubDate>Tue, 23 Feb 2016 00:52:42 +0800</pubDate>
      
      <guid>http://hzmangel.github.io/post/rails_elasticsearch_indexing/</guid>
      <description>

&lt;p&gt;之前写Rails在查找这块一般都是用DB内置的查询，不过上次试了下用 Elasticsearch ，比之前想像的要简单，记点东西在这吧。&lt;/p&gt;

&lt;p&gt;这篇东西会包含下面几项内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装 Elasticsearch&lt;/li&gt;
&lt;li&gt;关联 Rails 与 Elasticsearch&lt;/li&gt;
&lt;li&gt;配置索引内容&lt;/li&gt;
&lt;li&gt;Custom Analyzer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文没有完整系统的介绍，更多的只是一些使用技巧。详细说明请参见[官方文档]()。&lt;/p&gt;

&lt;h2 id=&#34;安装elasticsearch&#34;&gt;安装Elasticsearch&lt;/h2&gt;

&lt;p&gt;两种方法，从官网下编译好的&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/_installation.html&#34;&gt;二进制解压&lt;/a&gt;，或者用&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/master/setup-repositories.html&#34;&gt;操作系统的安装源&lt;/a&gt;。如果是OSX，可以使用 &lt;em&gt;homebrew&lt;/em&gt; 安装，命令为 &lt;code&gt;brew install elasticsearch&lt;/code&gt; ，安装后的启动可以使用 &lt;code&gt;brew info elasticsearch&lt;/code&gt; 查看。&lt;/p&gt;

&lt;p&gt;安装并启动服务后，可以用下面的命令查看系统是否成功启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -X GET &#39;http://localhost:9200&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一切正常，会返回服务器的状态信息。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;关联-rails-与-elasticsearch&#34;&gt;关联 Rails 与 Elasticsearch&lt;/h2&gt;

&lt;h3 id=&#34;gem&#34;&gt;Gem&lt;/h3&gt;

&lt;p&gt;Elasticsearch提供了两个Gem用于和Rails集成，分别是 &lt;a href=&#34;https://github.com/elastic/elasticsearch-rails&#34;&gt;&lt;em&gt;elasticsearch-rails&lt;/em&gt;&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/elastic/elasticsearch-rails/tree/master/elasticsearch-model&#34;&gt;&lt;em&gt;elasticsearch-model&lt;/em&gt;&lt;/a&gt; 。其中， &lt;em&gt;elasticsearch-rails&lt;/em&gt; 为 Rails 的模块加入了 Elasticsearch 的功能，而 &lt;em&gt;elasticsearch-model&lt;/em&gt; 则为 Ruby 的类提供了一些简化的连接 &lt;em&gt;Elasticsearch&lt;/em&gt; 的方法，使得相应的类可以通过 &lt;code&gt;__elasticsearch__&lt;/code&gt; 直接访问 &lt;em&gt;Elasticsearch&lt;/em&gt; 服务器的资源。&lt;/p&gt;

&lt;h3 id=&#34;model-enable-indexes-in-elasticsearch&#34;&gt;Model - Enable indexes in Elasticsearch&lt;/h3&gt;

&lt;p&gt;由于 Elasticsearch 是一个单独的服务器，所以在使用前需要考虑以下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有哪些Model需要被索引&lt;/li&gt;
&lt;li&gt;每个Model有哪些字段需要被索引&lt;/li&gt;
&lt;li&gt;如何在数据库中记录更新后同步 Elasticsearch 的索引&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果不使用 Elasticsearch 提供的 gem，需要手动去完成上面的几个步骤，但是上面提到的两个 gem 提供了一系列方便使用的函数。代码的东西对着说比较好弄，所以这里有一个 [Demo Project]()，对着来说吧。&lt;/p&gt;

&lt;p&gt;这个app就是一个简单的blog，由于只是为了介绍 Elasticsearch ，所以只引入了最简单的部分。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;app/models/blog.rb&lt;/code&gt; 中可以看到，需要索引一个 model 需要三步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在代码中加入 Elasticsearch 的模块。&lt;/li&gt;
&lt;li&gt;设置需要索引的模块。&lt;/li&gt;
&lt;li&gt;导入数据至 Elasticsearch 。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于需要索引的Model，只需要在代码中加上几行即可以调用 Elasticsearch 的功能。可以在 &lt;code&gt;app/models/blog.rb&lt;/code&gt; 中看到下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;elasticsearch/model&#39;

class Blog &amp;lt; ActiveRecord::Base
  include Elasticsearch::Model
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在加入了这几行代码后，这个Model就可以通过 &lt;code&gt;__elasticsearch__&lt;/code&gt; 来调用Elasticsearch的API了。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Blog.__elasticsearch__.client.cluster.health
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，只是在Blog中导入了一些Elasticsearch相关的配置，但是还没有将具体的数据导入到Elasticsearch服务器中。可以使用下面的命令导入数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Blog.import force: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者逐步完成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Blog.__elasticsearch__.create_index! force: true
Blog.__elasticsearch__.refresh_index!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是由于 Elasticsearch 的索引是和model分开存放的，所以在每次数据有更新时，需要手动更新所更新文档的索引。如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Blog.first.__elasticsearch__.index_document
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过Elasticsearch提供了Callback的方式来处理这些操作，只需要在Model中加入如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;include Elasticsearch::Model::Callbacks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可在每次数据有更新时，自动更新索引。在Gem的文档中还有一些更详细的用法，如异步索引，自定义索引等供查阅。&lt;/p&gt;

&lt;p&gt;在数据导入完成后即可尝试在 Elasticsearch 查找导入的数据了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Blog.search(&#39;*&#39;).records.records
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;model-choose-indexed-fields&#34;&gt;Model - Choose indexed fields&lt;/h3&gt;

&lt;p&gt;默认情况下，所有字段都会被加入 Elasticsearch 的索引。但是在实际使用情况中，可能会碰到只索引某些数据的场景。 Elasticsearch 提供了一个函数用来指定需要索引的字段以及对应的值。函数的名称是 &lt;code&gt;as_indexed_json&lt;/code&gt; 。这个函数是在 &lt;code&gt;Elasticsearch::Model::Serializing&lt;/code&gt; 定义的，如果需要定制，直接在Model中重新定义自己的函数就好。如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;elasticsearch/model&#39;

class Blog &amp;lt; ActiveRecord::Base
  include Elasticsearch::Model

  def as_indexed_json(options = {})
    as_json(
      only: [:title, :content]
    )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中，无论我的Blog记录中还有什么字段，只有 &lt;em&gt;title&lt;/em&gt; 和 &lt;em&gt;content&lt;/em&gt; 字段会被放入 Elasticsearch 的索引中，也只有这两个字段会返回在查询的结果中。除了内置字段外，还支持将函数中方法的返回值也加入索引中，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;elasticsearch/model&#39;

class Blog &amp;lt; ActiveRecord::Base
  include Elasticsearch::Model

  def as_indexed_json(options = {})
    as_json(
      only: [:title, :content],
      methods: [:author_name, :tag_count],
    )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时在索引的字段和返回的结果中，会多出 &lt;em&gt;author_name&lt;/em&gt; 以及 &lt;em&gt;tag_count&lt;/em&gt; 的返回值。这种方式可以指定关联记录的索引信息。除此之外，还可以在 &lt;code&gt;include&lt;/code&gt; 中使用嵌套的字段来标明关系记录。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;elasticsearch/model&#39;

class Blog &amp;lt; ActiveRecord::Base
  include Elasticsearch::Model

  def as_indexed_json(options = {})
    as_json(
      only: [:title, :content],
      include: { author: {only: :name}, tag: {methods: [:count]} }
    )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，基本的索引构建应该差不多了，在调用过 &lt;em&gt;import&lt;/em&gt; 后，就可以用基本的查询功能去查找了。&lt;/p&gt;

&lt;h2 id=&#34;analyzer-和-mapping&#34;&gt;&lt;em&gt;Analyzer&lt;/em&gt; 和 &lt;em&gt;Mapping&lt;/em&gt;&lt;/h2&gt;

&lt;h3 id=&#34;analyzer&#34;&gt;&lt;em&gt;Analyzer&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;对每一条被索引的内容， ES 都会通过 &lt;em&gt;Analyzer&lt;/em&gt; 把内容分词后放入服务器（因为ES中是使用 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95&#34;&gt;反向索引&lt;/a&gt; 来查找的，而反向索引的 &lt;em&gt;token&lt;/em&gt; 就是输入文字经过 &lt;em&gt;Analyzer&lt;/em&gt; 处理的结果）。而在查询时，如果是全文检索，那么 ES 会将和分析内容时使用的相同的 &lt;em&gt;Analyzer&lt;/em&gt; 应用于检索词上，并将分词后的检索词用于查找以提高查找的准确性。而如果查询的类型是精确匹配， ES 将不会处理检索词。&lt;/p&gt;

&lt;p&gt;根据 &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/guide/current/analysis-intro.html&#34;&gt;文档&lt;/a&gt; 的介绍，每一个 &lt;em&gt;Analyzer&lt;/em&gt; 由 &lt;strong&gt;3&lt;/strong&gt; 步组成，分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Character filters&lt;/em&gt; : 对输入的内容按字符处理，包含有 &lt;em&gt;Mapping Char Filter&lt;/em&gt;, &lt;em&gt;HTML Strip Char Filter&lt;/em&gt; 和 &lt;em&gt;Pattern Replace Char Filter&lt;/em&gt; ，具体介绍请参阅 &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-charfilters.html&#34;&gt;文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Tokenizer&lt;/em&gt; : 分词器，根据不同的规则，将输入内容分为不同的 token ，&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html&#34;&gt;文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Token filters&lt;/em&gt; : 应用于上面分割开的 &lt;em&gt;token&lt;/em&gt; 上的 filter。 &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenfilters.html&#34;&gt;文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ES 还提供了一些内置的 &lt;em&gt;Analyzer&lt;/em&gt; ，可以在 &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-analyzers.html&#34;&gt;这里&lt;/a&gt; 查到。由于 Rails 中的代码实例会牵涉到 &lt;em&gt;Mapping&lt;/em&gt; 相关的内容，所以会在下一节中贴代码。&lt;/p&gt;

&lt;h3 id=&#34;mapping&#34;&gt;&lt;em&gt;Mapping&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;对于输入的文本内容，ES会默认将此字段映射为 &lt;em&gt;string&lt;/em&gt; 类型，并使用 &lt;em&gt;standard analyzer&lt;/em&gt; ，如果需要一些特殊处理，就需要引入 &lt;em&gt;Mapping&lt;/em&gt; 了。 &lt;em&gt;Mapping&lt;/em&gt; 的作用是告诉 ES 某个字段需要按什么样的规则处理。例如一个手机号， ES 的默认处理是按长整形，但是可能需要按字符串处理，这时就需要指定 &lt;em&gt;Mapping&lt;/em&gt; 了。&lt;/p&gt;

&lt;p&gt;在 Rails 的 Model 中，可以通过下面的方法来设置字段的 &lt;em&gt;Analyzer&lt;/em&gt; 和 &lt;em&gt;Mapping Type&lt;/em&gt; ，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;settings do
  mappings do
    indexes :title, analyzer: &#39;english&#39;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上述的例子中，原本 &lt;em&gt;title&lt;/em&gt; 字段的 &lt;em&gt;analyzer&lt;/em&gt; 被指定为 &lt;em&gt;english&lt;/em&gt; 而不是默认的 &lt;em&gt;string&lt;/em&gt; 。&lt;/p&gt;

&lt;p&gt;Q: 为什么设定了type后，import返回值为1，而不设的时候返回是0？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Use Different Auth Method In Rails API Controller
</title>
      <link>http://hzmangel.github.io/post/different_auth_method_in_rails_api/</link>
      <pubDate>Wed, 27 Jan 2016 23:21:42 +0800</pubDate>
      
      <guid>http://hzmangel.github.io/post/different_auth_method_in_rails_api/</guid>
      <description>&lt;p&gt;开发的时候碰到一个问题，Rails的controller是用devise来提供认证的，如果用户在访问时没有有效的cookie就会被转到登录界面。但是在API的时候不能用cookie，所以需要分开做验证。&lt;/p&gt;

&lt;p&gt;基本想法是对于网页端的请求，继续使用devise进行认证，而对于某些同时提供API接口的Action，则使用token来验证。除此之外，对于POST请求，还需要跳过CSRF token的检查。基本上代码就是这样的（为了测试方便，使用了自己定义的&lt;code&gt;before_action&lt;/code&gt; ，同时设置所有的检查都基于请求中的 &lt;em&gt;token&lt;/em&gt; 字段。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class WelcomeController &amp;lt; ApplicationController
  before_action :auth_user!, only: [:foo], unless: -&amp;gt; { request.format.json? }
  before_action :auth_by_token!, if: -&amp;gt; { request.format.json? }

  def foo
    render json: params
  end

  def bar
    render json: params
  end

  private

  def auth_user!
    head :forbidden if params[:token] != &#39;24&#39;
  end

  def auth_by_token!
    head :forbidden if params[:token] != &#39;42&#39;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时，如果使用浏览器访问 &lt;em&gt;foo&lt;/em&gt; , &lt;code&gt;request.format&lt;/code&gt; 为 &lt;em&gt;text/html&lt;/em&gt; ，此时就会调用 &lt;code&gt;auth_user!&lt;/code&gt; ，而访问 &lt;em&gt;bar&lt;/em&gt; 时，即使是使用浏览器，也不会调用 &lt;code&gt;auth_user!&lt;/code&gt; 。而对于API请求，统一都会调用 &lt;code&gt;auth_by_token!&lt;/code&gt; 进行邓处理。&lt;/p&gt;

&lt;p&gt;下面是一个简单的测试用例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &amp;quot;rails_helper&amp;quot;

RSpec.describe WelcomeController, :type =&amp;gt; :controller do
  describe &#39;GET #foo.html&#39; do
    it &#39;responds forbidden if not given valid token&#39; do
      get :foo
      expect(response).to have_http_status(:forbidden)
    end

    it &#39;responds forbidden if given wrong token&#39; do
      get :foo, {token: 42}
      expect(response).to have_http_status(:forbidden)
    end

    # auth_user! is invoked
    it &#39;responds success if given correct token&#39; do
      get :foo, {token: 24}
      expect(response).to have_http_status(:ok)
    end
  end

  describe &#39;GET #foo.json&#39; do
    before :each do
      request.env[&amp;quot;HTTP_ACCEPT&amp;quot;] = &#39;application/json&#39;
    end

    it &#39;responds forbidden if not given valid token&#39; do
      get :foo
      expect(response).to have_http_status(:forbidden)
    end

    it &#39;responds forbidden if given wrong token&#39; do
      get :foo, {token: 24}
      expect(response).to have_http_status(:forbidden)
    end

    # auth_by_token! is invoked
    it &#39;responds success if given correct token&#39; do
      get :foo, {token: 42}
      expect(response).to have_http_status(:ok)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在老版本的Rails上，有一个&lt;a href=&#34;https://github.com/rails/rails/issues/9703&#34;&gt;bug#9703&lt;/a&gt;，就是它的判断会把 if/unless 和 only/except 分开处理。在这种情况下需要根据 &lt;a href=&#34;https://github.com/rails/rails/issues/9703#issuecomment-15830313&#34;&gt;此条评论&lt;/a&gt; 中的内容对代码做相应改动。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>