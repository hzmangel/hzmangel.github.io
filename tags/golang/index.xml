<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on 湖间小筑</title>
    <link>http://hzmangel.github.io/tags/golang/</link>
    <description>Recent content in Golang on 湖间小筑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright - ©2015 - hzmangel</copyright>
    <lastBuildDate>Mon, 07 Dec 2015 21:15:45 +0800</lastBuildDate>
    <atom:link href="http://hzmangel.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go generate study
</title>
      <link>http://hzmangel.github.io/post/go-generate-struct-to-schema/</link>
      <pubDate>Mon, 07 Dec 2015 21:15:45 +0800</pubDate>
      
      <guid>http://hzmangel.github.io/post/go-generate-struct-to-schema/</guid>
      <description>

&lt;p&gt;最近在折腾用Golang弄DB，定义完了 &lt;code&gt;struct&lt;/code&gt; 后发现好像没有 ORM 可以把这个 &lt;code&gt;struct&lt;/code&gt; 给映射到某张表上，所以需要：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;手动创建表结构，包括折腾表名和数据结构&lt;/li&gt;
&lt;li&gt;同步代码中的字段和表结构&lt;/li&gt;
&lt;li&gt;如果要换DB还得再来一次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是，开始找有没有像 Rails 中一样的生成器。&lt;/p&gt;

&lt;p&gt;最开始是想用一个脚本解析struct，生成相应的代码，但是在查文档的时候发现golang在1.4版本中引入了 &lt;a href=&#34;https://golang.org/doc/go1.4#gogenerate&#34;&gt;generate&lt;/a&gt; 命令，它可以解析一个文件并生成另一个文件。官方给的说明里面是从yacc的语法生成go文件。想了想觉得它可以完成生成SQL命令，同步struct和SQL的功能，而且如果做了处理的话还可以方便的在DB间切换，那就试试吧。&lt;/p&gt;

&lt;h2 id=&#34;语法:ccc7399e1d95744ff35922b65c36cc73&#34;&gt;语法&lt;/h2&gt;

&lt;p&gt;在介绍如何编写前，先介绍下调用的方式。要成功调用一次generate需要两个条件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;已经安装的generator&lt;/li&gt;
&lt;li&gt;在需要处理的代码中加上 &lt;code&gt;//go:generate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样在文件所在的目录下运行 &lt;code&gt;go generate&lt;/code&gt; 即可根据注释中所指示的方法，调用相应的生成器了。&lt;/p&gt;

&lt;h2 id=&#34;编写:ccc7399e1d95744ff35922b65c36cc73&#34;&gt;编写&lt;/h2&gt;

&lt;p&gt;Golang给出的sample是一个字符串相关的东西，具体可以见 &lt;a href=&#34;https://godoc.org/golang.org/x/tools/cmd/stringer&#34;&gt;文档页&lt;/a&gt;。&lt;a href=&#34;http://www.onebigfluke.com/2014/12/generic-programming-go-generate.html&#34;&gt;另一个页面&lt;/a&gt; 也有一份具体的实现可以参考。它主要的思路就是用 &lt;code&gt;generate&lt;/code&gt; 去处理某个 &lt;code&gt;.go&lt;/code&gt; 文件，然后生成一些新的东西。主要是用内置的 &lt;em&gt;AST&lt;/em&gt; 解析文件，并生成相应的东西。&lt;/p&gt;

&lt;h2 id=&#34;我的实现:ccc7399e1d95744ff35922b65c36cc73&#34;&gt;我的实现&lt;/h2&gt;

&lt;p&gt;回到最开始的问题，我有一个定义好的struct，需要去生成SQL命令。所以还是需要用到内置的AST解析器的。除此之外也就是一点点的区分类型型，做转换了。代码放在 &lt;a href=&#34;https://github.com/hzmangel/struct2schema&#34;&gt;https://github.com/hzmangel/struct2schema&lt;/a&gt; 这里，README还在编写中。目前代码支持将大部分Go内置的类型转换为SQL类型，不过可能还是有一些不支持的需要手动操作。在DB支持上，目前只看了sqlite3和MySQL。下一步要做的事情估计有这些：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持更多的DB类型，如PostgreSQL， MSSQL 等（Mongo这种无结构的就不需要了&amp;hellip;&amp;hellip;）&lt;/li&gt;
&lt;li&gt;现在生成的SQL命令中，字段名和Go中的变量名一致，都是Camel String，拟在解析的时候将其变为下划线小写的方式来生成SQL命令（考虑从后面的json字段获取小写名）&lt;/li&gt;
&lt;li&gt;支持更多的Go数据类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前生成出来的代码会直接打印到屏幕上，格式啥的，据说1.6上对模板会有一个更新， &lt;a href=&#34;https://github.com/golang/go/issues/9969&#34;&gt;讨论在此&lt;/a&gt; ，拭目以待。&lt;/p&gt;

&lt;h2 id=&#34;后记:ccc7399e1d95744ff35922b65c36cc73&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;在写这篇文章的时候，突然反应过来这个 &lt;code&gt;go generate&lt;/code&gt; 就是会调用在注释中写的命令，根据给定的参数处理。所以理论上说可以给定任何文件，所以还是有不少可玩性的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Control Goroutines amount via bufferred channel</title>
      <link>http://hzmangel.github.io/post/1239/</link>
      <pubDate>Sat, 19 Apr 2014 23:23:51 +0000</pubDate>
      
      <guid>http://hzmangel.github.io/post/1239/</guid>
      <description>&lt;p&gt;最近还是在写爬虫，然后发现用goroutine是很快，但是很容易就碰到并发数过多被服务器限制的问题。虽然说让goroutine在起来前睡一小会能解决一些问题
，但是终归感觉这样的办法不靠谱。继续翻文档发现&lt;code&gt;bufferred channel&lt;/code&gt;用在这不错。###  Bufferred Channel&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Bufferred channel&lt;/code&gt;和&lt;a href=&#34;http://www.hzmangel.info/blog/archives/1230&#34;&gt;前一篇文章&lt;/a&gt;中说的东西没
有太大差别，只是那篇文章中说的channel是不带缓存的，也就是相当于Semaphore的用法，而加了缓存的就是管道。不多说了，直接上代码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;
import &amp;quot;time&amp;quot;

func main() {

    channel_cnt := 10
    concurrency_chan := make(chan bool, 2)
    msg_chan := make(chan string)

    fmt.Println(&amp;quot;Start launching goroutines&amp;quot;)
    for i := 0; i &amp;lt; channel_cnt; i++ {
        go foo(i, concurrency_chan, msg_chan)
    }
    fmt.Println(&amp;quot;Finish launching goroutines&amp;quot;)

    for i := 0; i &amp;lt; channel_cnt; i++ {
        fmt.Println(&amp;lt;-msg_chan)
    }

}

func foo(i int, concurrency_chan chan bool, msg_chan chan string) {
    concurrency_chan &amp;lt;- true
    s := fmt.Sprintf(&amp;quot;%s: Call index %d&amp;quot;, time.Now(), i)
    msg_chan &amp;lt;- s
    time.Sleep(1 * time.Second)
    &amp;lt;-concurrency_chan
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段程序创建了两个&lt;code&gt;channel&lt;/code&gt;，而&lt;code&gt;concurrency_chan&lt;/code&gt;就是一个用来控制goroutine数量的&lt;code&gt;channel&lt;/code&gt;。在每个&lt;code&gt;gorout
ine&lt;/code&gt;开始的时候，会往这个&lt;code&gt;channel&lt;/code&gt;中写入一个值，而在函数结束的时候从&lt;code&gt;channel&lt;/code&gt;中把东西取出来。当&lt;code&gt;channel&lt;/code&gt;中的缓存被占满的时候，
后续的写入请求就会被阻塞，从而达到限制&lt;code&gt;goroutine&lt;/code&gt;个数的目的。代码和输出结果可以看&lt;a href=&#34;http://play.golang.org/p/8-
qUxtH0gp&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang and JSON API</title>
      <link>http://hzmangel.github.io/post/1233/</link>
      <pubDate>Thu, 20 Feb 2014 01:44:55 +0000</pubDate>
      
      <guid>http://hzmangel.github.io/post/1233/</guid>
      <description>

&lt;p&gt;最近在尝试用golang做爬虫类的东西，避免不了需要处理JSON API。其间碰到了些问题，记在这里以便下次查阅。### 生成URL&lt;/p&gt;

&lt;p&gt;嗯，反正我的blog已经被墙了，所以这次就用不存在的网站来作为示例吧。这个网站的名字叫Facebook（其实是不想为国内的账号上传身份证，所以只有用国外的A
PI了）。找了一圈，决定拿这个不存在的网站的CEO来测试。&lt;/p&gt;

&lt;p&gt;用的是Facebook提供的&lt;a href=&#34;https://developers.facebook.com/docs/graph-
api&#34;&gt;Graph API&lt;/a&gt;，下面演示的是如何用golang拼出来一个URL：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/url&amp;quot;
)

func main() {
    fmt.Println(userinfo_api(&amp;quot;4&amp;quot;, &amp;quot;&amp;quot;))
}

func userinfo_api(account_id string, access_token string) string {
    base_url := &amp;quot;http://graph.facebook.com/&amp;quot;

    params := make(url.Values)
    params.Set(&amp;quot;fields&amp;quot;, &amp;quot;id,name,picture&amp;quot;)
    if access_token != &amp;quot;&amp;quot; {
        params.Set(&amp;quot;access_token&amp;quot;, access_token)
    }

    api_url := base_url + account_id + &amp;quot;?&amp;quot; + params.Encode()

    return api_url
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序会在终端上打印出一个编码过的URL地址。这个地址直接贴到浏览器里面是会返回错误信息的，所以下一步我们需要在golang中去访问这个地址。多提一句，到目前
为止还不需要科学上网的技能。还是一样，如果不想在本机测试结果，可以到&lt;a href=&#34;http://play.golang.org/p/mhBQxRwTmF&#34;&gt;这个地址&lt;/a&gt;去
瞧一瞧看一看。&lt;/p&gt;

&lt;h3 id=&#34;调用api:2e6ed15c900da4872231994fbb6e0e50&#34;&gt;调用API&lt;/h3&gt;

&lt;p&gt;在网上查了查发现大家对golang自带的http库表示比较满意，所以本着少用第三方库的原则，就直接使用了内置的&lt;code&gt;http&lt;/code&gt;库来获取JSON。程序如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;net/url&amp;quot;
)

func main() {
    info_api := userinfo_api(&amp;quot;4&amp;quot;, &amp;quot;&amp;quot;)
    fmt.Println(info_api)
    get_api_resp(info_api)
}

func userinfo_api(account_id string, access_token string) string {
    base_url := &amp;quot;http://graph.facebook.com/&amp;quot;

    params := make(url.Values)
    params.Set(&amp;quot;fields&amp;quot;, &amp;quot;id,name,picture&amp;quot;)
    if access_token != &amp;quot;&amp;quot; {
        params.Set(&amp;quot;access_token&amp;quot;, access_token)
    }

    api_url := base_url + account_id + &amp;quot;?&amp;quot; + params.Encode()

    return api_url
}

func get_api_resp(api_url string) {
    resp, err := http.Get(api_url)
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()

    fmt.Println(resp)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，直接使用&lt;code&gt;http.Get&lt;/code&gt;即可向服务器端发送GET请求。这个程序最后打印出来的&lt;code&gt;resp&lt;/code&gt;是一个&lt;code&gt;http.Response&lt;/code&gt;的类型，而我们真正
需要的是这个响应所带来的内容，所以需要用下面的调用来取得真正的响应内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import &amp;quot;io/ioutil&amp;quot;

...

content, err := ioutil.ReadAll(resp.Body)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时得到的&lt;code&gt;content&lt;/code&gt;是&lt;code&gt;[]byte&lt;/code&gt;类型的数据，即&lt;code&gt;byte&lt;/code&gt;类型的数组，如果直接用&lt;code&gt;fmt.Println(content)&lt;/code&gt;打印出来则会在屏幕
上显示数据的Ascii码，所以如果想以字符串的形式打印到屏幕上需要将其转换为string类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(string(content))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时屏幕上显示的即是正常的JSON响应了。&lt;/p&gt;

&lt;h3 id=&#34;处理json数据:2e6ed15c900da4872231994fbb6e0e50&#34;&gt;处理JSON数据&lt;/h3&gt;

&lt;p&gt;此时的JSON数据还只是一个字符串，程序并不认为它和其它的字符串有什么不同，此时就需要使用内置的JSON库去解码，解码所得的结果放于&lt;code&gt;map&lt;/code&gt;结构中。&lt;/p&gt;

&lt;p&gt;golang的解码有两种方式。第一种方式是明确知道返回JSON的数据格式，包括返回数据的结构，每一项的名称，以及值的类型，这种类型的返回数据可以直接解码到预
先定义的&lt;code&gt;struct&lt;/code&gt;中，然后使用点操作符调用获取其中的值，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type userinfo_api_resp struct {
    Id      string
    Name    string
    Picture userinfo_picture_data_wrapper
}

type userinfo_picture_data_wrapper struct {
    Data userinfo_picture_data_detail
}

type userinfo_picture_data_detail struct {
    Url           string
    Is_silhouette bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在定义好这些内容后，使用下面的代码负责把JSON内容填入其中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// content saves json repsonse in []byte formated
err = json.Unmarshal(content, &amp;amp;json_rslt)
if err != nil {
    panic(err)
}
fmt.Println(json_rslt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时即可以像普通的struct那样调用JSON中的值了，如使用&lt;code&gt;json_rslt.Name&lt;/code&gt;可以获取到名字，用&lt;code&gt;json_rslt.Picture.Dat
a.Url&lt;/code&gt;可以获取到图片的地址等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;struct&lt;/code&gt;中字段名的首字母都需要大写，猜测是由于golang中非首字母大写的变量不会被导出。（话说，真的好想好想吐槽这个设定啊，实在不习惯看大小写混杂的变量名，诶。）&lt;/p&gt;

&lt;p&gt;当JSON返回的格式未知，或者不想定义过多的struct时，可以使用第二种方法。&lt;code&gt;interface{}&lt;/code&gt;。这个东西是一个空的&lt;code&gt;interface&lt;/code&gt;，表示的
是一个没有任何方法的&lt;code&gt;interface&lt;/code&gt;，因为任何golang的类型都至少实现了0个方法（唔，直接翻译过来的，读着有点拗口，回头揣摩明白了再回来改），所以
这个类型实际可以用于任何类型的变量。第二种方法就是使用&lt;code&gt;interface{}&lt;/code&gt;来表示所有未定的类型，然后由程序去处理相应的数据。还是上面那段JSON数据，
想取到图片地址，则需要这么处理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;json_rslt := map[string]interface{}{}

...

for k1, v1 := range json_rslt {
    if k1 == &amp;quot;picture&amp;quot; {
        for k2, v2 := range v1.(map[string]interface{}) {
            if k2 == &amp;quot;data&amp;quot; {
                for k3, v3 := range v2.(map[string]interface{}) {
                    if k3 == &amp;quot;url&amp;quot; {
                        fmt.Println(v3)
                    }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;唔，其实也没简单到哪去的感觉&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;range&lt;/code&gt;后调用的诸如&lt;code&gt;v1.(map[string]interface{})&lt;/code&gt;被称为&lt;a href=&#34;http://golan
g.org/ref/spec#Type_assertions&#34;&gt;&lt;em&gt;type assertions&lt;/em&gt;&lt;/a&gt;，它的意思是断言&lt;code&gt;v1&lt;/code&gt;非空而且&lt;code&gt;v1&lt;/code&gt;的类型是&lt;code&gt;(map[string]interface{
})&lt;/code&gt;。文档中给出的更加精确的说法是&lt;code&gt;x.(T)&lt;/code&gt;表示&lt;code&gt;x&lt;/code&gt;的动态类型和&lt;code&gt;T&lt;/code&gt;一致，&lt;code&gt;T&lt;/code&gt;必需实现&lt;code&gt;x&lt;/code&gt;的所有接口。更加具体的代码请参考文档&lt;/p&gt;

&lt;p&gt;到这，差不多就完成了，POST请求的事情还没用到，等用到后发现有什么需要写的再写吧。另外需要注意的一点是，&lt;a href=&#34;http://play.golang.org/&#34;&gt;http://play.golang.org/&lt;/a&gt;
网站上是不允许使用&lt;code&gt;net/http&lt;/code&gt;库的，所以我后面的程序才没有给出代码链接，有兴趣的可以在自己机器上试验，记得要科学上网哦，要不然就会返回奇怪的结果了～&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>goroutines &#43; channel</title>
      <link>http://hzmangel.github.io/post/1230/</link>
      <pubDate>Mon, 17 Feb 2014 01:40:16 +0000</pubDate>
      
      <guid>http://hzmangel.github.io/post/1230/</guid>
      <description>

&lt;p&gt;&lt;code&gt;channel&lt;/code&gt;是golang里面一个比较有意思的东西，可以把它看成是一个semaphone（无缓存版队列）或者FIFO（有缓存版队列）。这篇文章只是把最
近用到的一些东西归纳了一下，就算是给自己留份存档吧。&lt;code&gt;channel&lt;/code&gt;是需要和&lt;code&gt;goroutines&lt;/code&gt;一起使用的。&lt;/p&gt;

&lt;h3 id=&#34;goroutines:c6debf44b3ea0c5c4c8edcf6064ff030&#34;&gt;goroutines&lt;/h3&gt;

&lt;p&gt;先说&lt;code&gt;goroutines&lt;/code&gt;吧。golang的并行模型使用的是&lt;strong&gt;CSP&lt;/strong&gt;（官方的说法是Newsqueak-Alef-Limbo，和原始的CSP有一些区别
。具体的差别还没有细查。参见&lt;a href=&#34;http://talks.golang.org/2012/concurrency.slide#10&#34;&gt;此张幻灯片&lt;/a&gt; ），&lt;code&gt;go
routines&lt;/code&gt;是一个独立运行的函数，不是进程也不是线程。它在被调用或者说被启动后直接返回，而不用等待函数运行结束。这是官方对它的一段&lt;a href=&#34;htt
p://talks.golang.org/2012/concurrency.slide#17&#34;&gt;简要介绍&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What is a goroutine? It&amp;rsquo;s an independently executing function, launched by a go statement.&lt;/li&gt;
&lt;li&gt;It has its own call stack, which grows and shrinks as required.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s very cheap. It&amp;rsquo;s practical to have thousands, even hundreds of thousands of goroutines.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s not a thread.&lt;/li&gt;
&lt;li&gt;There might be only one thread in a program with thousands of goroutines.&lt;/li&gt;
&lt;li&gt;Instead, goroutines are multiplexed dynamically onto threads as needed to keep all the goroutines running.&lt;/li&gt;
&lt;li&gt;But if you think of it as a very cheap thread, you won&amp;rsquo;t be far off.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;goroutines&lt;/code&gt;使用&lt;code&gt;go&lt;/code&gt;关键字来创建，创建完后就自己蹲一边运行去了，主程序也不用理它，自己往下走就行。光看文字太枯燥，读程序看输出吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;
import &amp;quot;time&amp;quot;

func main() {
     fmt.Println(&amp;quot;START 1&amp;quot;)
     for i := 0; i &amp;lt; 3; i++ {
          foo(i)
     }
     fmt.Println(&amp;quot;END 1&amp;quot;)

     fmt.Println(&amp;quot;START 2&amp;quot;)
     for i := 0; i &amp;lt; 3; i++ {
          go foo(i)
     }
     fmt.Println(&amp;quot;END 2&amp;quot;)

     time.Sleep(1 * time.Second)
}

func foo(i int) {
     time.Sleep(1)
     fmt.Printf(&amp;quot;Call index: %d\n&amp;quot;, i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序的输出是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;START 1
Call index: 0
Call index: 1
Call index: 2
END 1
START 2
END 2
Call index: 0
Call index: 2
Call index: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中，main函数中用了两个循环，分别调用了3次foo()函数，但是两次调用的方式不同，第一次是直接调用，第二次是使用了&lt;code&gt;goroutine&lt;/code&gt;。从输出看，
前段输出是正常的顺序，但是从后一段输出可以看到，函数调用是立即返回的，而且最后输出的顺序也是不固定的（3次可能看到的效果比较一致，如果把循环次数涨到10次就
能看的比较明显了）。在第19行加上sleep的原因是因为main函数在执行完成后会直接退出，不会等待所有&lt;code&gt;goroutines&lt;/code&gt;执行完毕，所以此处需要让程序
等一等。不方便在本机运行的可以&lt;a href=&#34;http://play.golang.org/p/8BT6RVR7-w&#34;&gt;见这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;channel:c6debf44b3ea0c5c4c8edcf6064ff030&#34;&gt;channel&lt;/h3&gt;

&lt;p&gt;拿sleep来不让main函数退出也不是个事，毕竟时间不好控制，睡多了睡少了都不行，所以这里就引入了&lt;code&gt;channel&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;就像文章开头说的，&lt;code&gt;channel&lt;/code&gt;就像是一个Semaphore或者FIFO的东西，更通俗的理解就是一条传送带或者管道，用于在&lt;code&gt;goroutines&lt;/code&gt;之间传
递消息。把上面的程序改一下（顺序调用的那个就先去掉了，减少长度，嗯）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {

    foo_channel := make(chan string)
    channel_cnt := 3

    fmt.Println(&amp;quot;Start launching goroutines&amp;quot;)
    for i := 0; i &amp;lt; channel_cnt; i++ {
        go foo(i, foo_channel)
    }
    fmt.Println(&amp;quot;Finish launching goroutines&amp;quot;)

    for i := 0; i &amp;lt; channel_cnt; i++ {
        fmt.Println(&amp;lt;-foo_channel)
    }

}

func foo(i int, foo_channel chan string) {
    s := fmt.Sprintf(&amp;quot;Call index %d&amp;quot;, i)
    foo_channel &amp;lt;- s
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入是介样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Start launching goroutines
Finish launching goroutines
Call index 0
Call index 1
Call index 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个程序里面，没有使用&lt;code&gt;sleep&lt;/code&gt;，程序也做到了等待所有&lt;code&gt;goroutines&lt;/code&gt;运行完毕才退出这个需求，就是靠的main函数最后几行。blog上不知道为
啥没有行号了，程序&lt;a href=&#34;http://play.golang.org/p/FzHuVttKnB&#34;&gt;见这里吧&lt;/a&gt;。在第7行的时候创建了一个&lt;code&gt;channel&lt;/code&gt;，并把它
传入了&lt;code&gt;foo()&lt;/code&gt;函数中。而&lt;code&gt;foo()&lt;/code&gt;函数也不像上一次那样直接输出一个字符串，它把需要输出的字符串放到一个string中，然后通过&lt;code&gt;channel&lt;/code&gt;传
了回来。这条语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo_channel &amp;lt;- s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;做的就是把字符串放到channel中去，而这条语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(&amp;lt;-foo_channel)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;做的就是把字符串从channel中取出来，并把它输出。在执行&lt;code&gt;&amp;lt;-channel&lt;/code&gt;时，如果&lt;code&gt;channel&lt;/code&gt;上没有数据，这条语句是被blocked的，这样就
能保证main函数在所有goroutines执行完毕前不会退出。而且当channel中有值而且没有被读出的时候，对这个channel的写操作也是被block
ed的。这时的channel，可以用来做Semaphore。&lt;/p&gt;

&lt;p&gt;上面介绍的channel是没有缓存的，golang中还有一种channel是可以加上缓存的，&lt;a href=&#34;htt
p://talks.golang.org/2012/concurrency.slide#22A&#34;&gt;官方文档说这个就像是Erlang的mailboxes&lt;/a&gt;，因为不懂Erlang，所以只好把话贴在这以后两手一摊。目前
在项目中还没有用到带缓存的channel，暂时先不写了，估计在不远的将来还会有一篇关于&lt;code&gt;select&lt;/code&gt;的文章，目前时间未定，因为还没用到～&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>