<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elasticsearch on 湖间小筑</title>
    <link>http://hzmangel.github.io/tags/elasticsearch/</link>
    <description>Recent content in Elasticsearch on 湖间小筑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright - ©2015 - hzmangel</copyright>
    <lastBuildDate>Fri, 05 Feb 2016 11:29:42 +0800</lastBuildDate>
    <atom:link href="http://hzmangel.github.io/tags/elasticsearch/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Integrate Rails with Elasticsearch - Indexing
</title>
      <link>http://hzmangel.github.io/post/rails_elasticsearch_indexing/</link>
      <pubDate>Fri, 05 Feb 2016 11:29:42 +0800</pubDate>
      
      <guid>http://hzmangel.github.io/post/rails_elasticsearch_indexing/</guid>
      <description>

&lt;p&gt;之前写Rails在查找这块一般都是用DB内置的查询，不过上次试了下用Elasticsearch，比之前想像的要简单，记点东西在这吧。&lt;/p&gt;

&lt;h2 id=&#34;安装elasticsearch:7534e3005bc051c63c374ef8164540b2&#34;&gt;安装Elasticsearch&lt;/h2&gt;

&lt;p&gt;这块其实没有太多需要说的，两种方法，从官网下编译好的&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/_installation.html&#34;&gt;二进制解压&lt;/a&gt;，或者用&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/master/setup-repositories.html&#34;&gt;操作系统的安装源&lt;/a&gt;。如果是OSX，可以使用 &lt;em&gt;homebrew&lt;/em&gt; 安装，命令为 &lt;code&gt;brew install elasticsearch&lt;/code&gt; ，安装后的启动可以使用 &lt;code&gt;brew info elasticsearch&lt;/code&gt; 查看。&lt;/p&gt;

&lt;p&gt;安装并启动服务后，可以用下面的命令查看系统是否成功启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -X GET &#39;http://localhost:9200&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一切正常，会返回服务器的状态信息。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;配置rails:7534e3005bc051c63c374ef8164540b2&#34;&gt;配置Rails&lt;/h2&gt;

&lt;h3 id=&#34;gem:7534e3005bc051c63c374ef8164540b2&#34;&gt;Gem&lt;/h3&gt;

&lt;p&gt;Elasticsearch提供了两个Gem用于和Rails集成，分别是 &lt;code&gt;elasticsearch-rails&lt;/code&gt; 和 &lt;code&gt;elasticsearch-model&lt;/code&gt; ，两个Gem的作用如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TODO&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;model-enable-indexes-in-es:7534e3005bc051c63c374ef8164540b2&#34;&gt;Model - Enable indexes in ES&lt;/h3&gt;

&lt;p&gt;Elasticsearch是一个单独的服务器，所以在使用前需要考虑以下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有哪些Model需要被索引&lt;/li&gt;
&lt;li&gt;每个Model有哪些字段需要被索引&lt;/li&gt;
&lt;li&gt;如何在数据库中记录更新后同步Elasticsearch的索引&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果不使用Elasticsearch提供的gem，需要手动去完成上面的几个步骤，但是Elasticsearch的Gem提供了一系列方便使用的函数。&lt;/p&gt;

&lt;p&gt;对于需要索引的Model，只需要在代码中加上几行即可以调用 Elasticsearch 的功能。下面是一个Sample&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;elasticsearch/model&#39;

class Blog &amp;lt; ActiveRecord::Base
  include Elasticsearch::Model
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在加入了这几行代码后，这个Model就可以通过 &lt;code&gt;__elasticsearch__&lt;/code&gt; 来调用Elasticsearch的API了。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Blog.__elasticsearch__.client.cluster.health
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，只是在Blog中导入了一些Elasticsearch相关的配置，但是还没有将具体的数据导入到Elasticsearch服务器中。可以使用下面的命令导入数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Blog.__elasticsearch__.create_index! force: true
Blog.__elasticsearch__.refresh_index!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于Elasticsearch的索引是和model分开存放的，所以在每次数据有更新时，需要手动更新所更新文档的索引。如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Blog.first.__elasticsearch__.index_document
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过Elasticsearch提供了Callback的方式来处理这些操作，只需要在Model中引入相应的文件即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;include Elasticsearch::Model::Callbacks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在加入这行代码后，调用 &lt;strong&gt;一次&lt;/strong&gt; &lt;code&gt;Blog.import&lt;/code&gt; 即可完成下面的几步操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将 &lt;em&gt;Blog&lt;/em&gt; 中的数据导入 Elasticsearch 中&lt;/li&gt;
&lt;li&gt;加入相应的 &lt;em&gt;callback&lt;/em&gt; 函数，在Model数据有更新时，同步索引&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在运行完上述的命令（手动更新或自动索引）后，即可在Elasticsearch服务器中查找到相应的内容了。&lt;/p&gt;

&lt;h3 id=&#34;model-choose-indexed-fields:7534e3005bc051c63c374ef8164540b2&#34;&gt;Model - Choose indexed fields&lt;/h3&gt;

&lt;p&gt;在默认情况下，所有字段都会被索引。但是在实际使用中，并不是所有的字段都需要索引。Elasticsearch提供了一个函数用来指定需要索引的字段以及对应的值。函数的名称是 &lt;code&gt;as_indexed_json&lt;/code&gt; 。这个函数是在 &lt;code&gt;Elasticsearch::Model::Serializing&lt;/code&gt; 定义的，如果需要定制，直接在Model中重新定义自己的函数就好。下面是一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;elasticsearch/model&#39;

class Blog &amp;lt; ActiveRecord::Base
  include Elasticsearch::Model

  def as_indexed_json(options = {})
    as_json(
      only: [:title, :content]
    )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中，无论我的Blog记录中还有什么字段，只有 &lt;em&gt;title&lt;/em&gt; 和 &lt;em&gt;content&lt;/em&gt; 字段会被放入Elasticsearch的索引中，也只有这两个字段会返回在查询的结果中。除了内置字段外， &lt;code&gt;elasticsearch-model&lt;/code&gt; 还支持将函数中方法的返回值也加入索引中，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;elasticsearch/model&#39;

class Blog &amp;lt; ActiveRecord::Base include Elasticsearch::Model

  def as_indexed_json(options = {})
    as_json(
      only: [:title, :content],
      methods: [:author_name, :tag_count]
    )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时在索引的字段和返回的结果中，会多出 &lt;em&gt;author_name&lt;/em&gt; 以及 &lt;em&gt;tag_count&lt;/em&gt; 的返回值。这种方式可以指定关联记录的索引信息。除此之外，还可以在 &lt;code&gt;include&lt;/code&gt; 中使用嵌套的字段来标明关系记录。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;elasticsearch/model&#39;

class Blog &amp;lt; ActiveRecord::Base
  include Elasticsearch::Model

  def as_indexed_json(options = {})
    as_json(
      only: [:title, :content],
      include: { author: {only: :name}, tag: {methods: [:count]} }
    )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，基本的索引构建应该差不多了，后续会记一些查询的东西。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>